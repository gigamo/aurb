#!/usr/bin/env ruby
require 'rubygems'
require 'zlib'
require 'facets/minitar'
require 'facets/version'
require 'facets/ansicode'
require 'json'
require 'cgi'
require 'open-uri'
require 'optparse'
require 'pathname'

module Aurb
  Config = Struct.new(:search, :info, :sync, :dir)
  Version = {:major => 0, :minor => 5, :tiny => 2}

  def self.aur
    @aur ||= Aur.new
  end

  module Util
    def color(text, effect)
      ANSICode.send(effect.to_sym) << text << ANSICode.clear
    end
  end

  class AurbError < Exception; end

  class Aur
    include Aurb::Util

    def initialize
      @config = Config.new(
        'http://aur.archlinux.org/rpc.php?type=search&arg=%s',
        'http://aur.archlinux.org/rpc.php?type=info&arg=%s',
        '/var/lib/pacman/sync/community',
        # Change this to reflect your personal download path
        Pathname.new(File.join(ENV['HOME'], 'abs')).realpath
      )
      @opts = Opts.new(ARGV)
    end

    def start
      trap(:INT) { exit 0 }
      instance_eval(@opts[:cmd])
    rescue AurbError => e
      puts e.message
      exit 1
    end

    def download(*packages)
      packages.each do |package|
        puts "#{color('Warning', :on_yellow)}: directory for '#{package}' already exists" if File.exists? File.join(@config.dir, package)
        list(package).each do |names|
          if names.first == package
            Dir.chdir(@config.dir) do |dir|
              if in_sync? package
                puts "#{color('==>', :yellow)} Found #{package} in community repo. Pacman will do."
                exec "sudo pacman -S #{package}"
              else
                puts "#{color('==>', :yellow)} Downloading #{package}"
                fetch(package, dir)
              end
              puts "#{color('==>', :yellow)} Unpacking #{package}"
              untar(package)
            end
          end
        end
      end
    end

    def search(package)
      count, threads = 0, []
      list(package).each do |names|
        threads << Thread.new do
          result = json(@config.info % names[1])
          unless result['type'] == 'error'
            result = result['results']
            next if in_sync? result['Name'], 'community'
            if package.any? do |pac|
              (result['Name'].include?(pac)) || (result['Description'].include?(pac))
            end
              count += 1
              puts "[#{result['OutOfDate'] == '1' ? color('✘', :red) : color('✔', :green)}] #{color(result['Name'], :blue)} (#{result['Version']}): #{result['Description']}"
            end
          end
        end
      end
      threads.each { |t| t.join }

      puts "\n#{color('==>', :yellow)} Found #{color(count.to_s, :magenta)} #{count == 1 ? 'result' : 'results'}" if count > 0
    end

    def check_upgrade
      found, count, upgradable = false, 0, []
      puts "#{color('==>', :yellow)} Checking for upgrades"
      `pacman -Qm`.each_line do |line|
        name, version = line.chomp.split
        result = json(@config.info % name)
        unless result['type'] == 'error'
          result = result['results']
          if (result.is_a?(Hash)) && (result['Version'] != version)
            if VersionNumber.new(result['Version']) > VersionNumber.new(version)
              found = true
              count += 1
              upgradable << name
              puts "#{color(name, :bold)} (#{color(version, :red)}) can be upgraded to #{color(result['Version'], :green)}"
            end
          else
            puts "#{color(name, :bold)} (#{color(version, :green)}) is up to date"
          end
        end
      end

      if found
        puts "\n#{color('==>', :yellow)} Found #{color(count.to_s, :magenta)} #{count == 1 ? 'upgrade' : 'upgrades'}"
        upgradable.each do |pkg|
          print "#{color('==>', :yellow)} Download '#{pkg}'? [y] "
          $stdin.gets.chomp =~ /^y/ ? download(pkg) : next
        end
      else
        puts "\n#{color('==>', :yellow)} All packages are up to date."
      end
    end

  private
    def in_sync?(package)
      Dir["#{@config.sync}/#{package}-*"].first ? true : false
    end

    def list(package)
      info, list = json(@config.search % CGI::escape(package)), []
      if info['type'] == 'error'
        raise AurbError, "#{color('Fatal', :on_red)}: no results"
      end
      for result in info['results'] do
        list << [result['Name'], result['ID']]
      end
      list.sort unless list.empty?
    end

    def fetch(package, dir)
      open("http://aur.archlinux.org/packages/#{package}/#{package}.tar.gz") do |remote|
        File.open("#{dir}/#{package}.tar.gz", 'wb') do |local|
          local.write(remote.read)
        end
      end
    end

    def untar(package)
      Archive::Tar::Minitar.unpack(Zlib::GzipReader.new(File.open("#{package}.tar.gz", 'rb')), Dir.pwd)
    end

    def json(item)
      JSON.parse(open(item).read)
    end
  end

  class Opts < Hash
    def initialize(args = ARGV)
      @@args = args || ['-h']
      parse
    end

  private
    def parse
      OptionParser.new do |o|
        o.version      = '%s.%s.%s' % [:major, :minor, :tiny].map {|v| Version[v]}
        o.program_name = 'Aurb'
        o.release      = '2009-04-07'

        o.on('-D', '--download P1,P2,...', Array, 'Download package(s). Separate by commas if multiple (no spaces).') do |d|
          self[:cmd] = "download('#{d*"', '"}')"
        end
        o.on('-S', '--search PKG', 'Search for a package.') do |s|
          self[:cmd] = "search('#{s}')"
        end
        o.on('-U', '--upgrade', 'Check for upgrades.') do
          self[:cmd] = 'check_upgrade'
        end
      end.parse!(@@args)
    end
  end
end

at_exit do
  if __FILE__ == $0
    raise $! if $!
    Aurb.aur.start
  end
end
