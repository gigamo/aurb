#!/usr/bin/env ruby
#
# Author:: Gigamo &lt;gigamo@gmail.com&gt;
#                        _
#                       | |
#        __ _ _   _ _ __| |__
#       / _` | | | | '__| '_ \
#      | (_| | |_| | |  | |_) |
#       \__,_|\__,_|_|  |_.__/
#
#
# A Ruby AUR (Arch User Repository) utility.
# Inspired by arson &lt;http://github.com/evaryont/arson/tree/master&gt;
#

%w[optparse pathname fileutils zlib open-uri rubygems cgi json highline/import
   facets/ansicode facets/minitar facets/version].each {|lib| require lib}

module Aurb
# Default download path
  DlPath = File.join ENV['HOME'], 'abs'

# Program Info
  PrInfo = {:name => 'Aurb', :version => [0, 7, 2].join('.'), :release => '2009-04-24'}

  class << self
    def aur
      @aur ||= Aur.new \
        :search => proc {|t| "http://aur.archlinux.org/rpc.php?type=search&arg=#{t}"},
        :info   => proc {|t| "http://aur.archlinux.org/rpc.php?type=info&arg=#{t}"},
        :path   => Pathname.new(DlPath).realpath,
        :color  => true
    end
  end

  module Util
    def die message, code = 1
      say "#{ansi('Terminating:', :red, true)} #{message}"
      exit code.to_i
    end
    module_function :die

    def set_trap
      trap(:INT) {die "\nInterrupt signal received\n\n", 0}
    end

    def ansi text, effect, force = false
      text = ANSICode.send(effect.to_sym) << text.to_s << ANSICode.clear if \
        @config[:color] || force
      text
    end

    def yes_or_no? question
      ask(question, lambda {|yn| yn.downcase[0] == ?y}) do |q|
        q.readline              = true
        q.default               = 'y'
        q.validate              = /\Ay(?:es)?|no?\Z/i
        q.responses[:not_valid] = 'Yes or no, please'
      end
    end
  end

  class Aur
    include Aurb::Util

    def initialize config
      @opts   = Opts.new
      @config = config.merge(@opts.config)
    end

    def start
      set_trap
      instance_eval @opts.cmd
    end

    def download *packages
      packages = packages.first if packages.first.is_a?(Array)
      packages.delete_if {|pkg| in_sync?(pkg)}
      die 'No package(s) to download. Possibly the package(s) you ' +
        'specified was/were found in the community repository.' if packages.empty?
      say "Targets (#{ansi packages.length, :magenta}): #{packages.join(', ')}"

      if yes_or_no? 'Proceed? '
        packages.each do |package|
          list(package).each do |names|
            if names.first == package
              FileUtils.cd @config[:path] do
                fetch package
                untar package
              end
              say "(#{packages.index(package)+1}/#{packages.length}) downloaded #{package}"
            end
          end
        end
      end
    end

    def search package
      list(package).each do |names|
        result = json(@config[:info][names.last])

        unless result['type'] =~ /error/
          result = result['results']
          next if in_sync? result['Name']

          if package.any? {|pac| result['Name'].include?(pac) || result['Description'].include?(pac)}
            say "[#{result['OutOfDate'] == '1' ? ansi('✘', :red) : ansi('✔', :green)}] " +
              "#{ansi result['Name'], :blue} (#{result['Version']}): #{result['Description']}"
          end
        end
      end
    end

    def check_upgrade
      upgradable = []

      say 'Searching for updates'
      IO.popen('pacman -Qm', IO::RDONLY) {|pm| pm.read.lines}.each do |line|
        name, version = line.chomp.split
        result = json(@config[:info][name])

        unless result['type'] =~ /error/
          result = result['results']
          next if in_sync? result['Name']

          if VersionNumber.new(result['Version']) > VersionNumber.new(version)
            upgradable << result['Name']
            say " #{name}: #{ansi version, :red} => #{ansi result['Version'], :green}"
          end
        end
      end

      upgradable.any? ? download(upgradable) : say('Nothing to update')
    end

  private
    def in_sync? package
      !!Dir["/var/lib/pacman/sync/community/#{package}-*"].first
    end

    def list package
      info, list = json(@config[:search][CGI::escape(package)]), []

      unless info['type'] =~ /error/
        info['results'].each do |result|
          list << [result['Name'], result['ID']]
        end
      end

      list.sort
    end

    def fetch package
      FileUtils.rm "#{package}.tar.gz" if File.exists? "#{package}.tar.gz"

      open("http://aur.archlinux.org/packages/#{package}/#{package}.tar.gz") do |remote|
        File.open("#{package}.tar.gz", 'wb') do |local|
          local.write remote.read
        end
      end
    end

    def untar package
      die "#{package}.tar.gz was not found." unless File.exists? "#{package}.tar.gz"
      FileUtils.rm_r package if File.directory? package

      Archive::Tar::Minitar.unpack \
        Zlib::GzipReader.new(File.open("#{package}.tar.gz", 'rb')),
        Dir.pwd
    end

    def json item
      JSON.parse open(item).read
    end
  end

  class Opts
    attr_reader :cmd, :config, :color

    def initialize
      @@args, @config = (ARGV.any? ? ARGV : ['-h']), {}
    # Parse zeh ARGV!
      parse!
    end

  private
    include Aurb::Util

    def parse!
      OptionParser.new do |o|
        o.program_name, o.version, o.release = \
          [:name, :version, :release].map {|key| PrInfo[key]}

        o.separator 'Actions (Required):'
        o.on '-D', '--download P1,P2,...', Array, 'download package(s)' do |d|
          @cmd = "download('#{d*"', '"}')" # XXX: Very ugly. Makes instance_eval work though.
        end
        o.on '-S', '--search PKG', 'search for a package' do |s|
          @cmd = "search('#{s}')"
        end
        o.on '-U', '--upgrade', 'check the AUR for upgrades' do
          @cmd = 'check_upgrade'
        end
        o.separator 'Optional:'
        o.on '--save-to [PATH]', "download path [#{DlPath}]" do |d|
          if File.exists? d = (d[0...1] == '/' ? d : File.join(Dir.pwd, d))
            @config[:path] = Pathname.new(d).realpath
          else
            die "The path you specified doesn't exist"
          end
        end
        o.on '--[no-]color', 'use colors?' do |c|
          @config[:color] = c
        end
      end.parse! @@args
    rescue OptionParser::ParseError
      die 'I.. I think you broke it...'
    end
  end
end

at_exit do
  if __FILE__ == $0
    raise $! if $!
    Aurb.aur.start
  end
end
