#!/usr/bin/env ruby
require 'open-uri'
require 'rubygems'

module Aurb

DlPath = File.join(File.expand_path('~'), 'abs') # Change me!
Config = Struct.new :search, :info, :sync, :dir  # Don't change me!

def self.aur
  @aur ||= Aur.new
end

module Util
  # Colorize a string
  #
  #   ansi('Text', :green)
  #
  # For a full list of available effects, see
  # http://facets.rubyforge.org/doc/api/more/classes/ANSICode.html
  def ansi text, effect
    require 'facets/ansicode' unless defined? ANSICode

    ANSICode.send(effect.to_sym) << text << ANSICode.clear
  end
end

class AurbError < Exception; end

class Aur
  include Aurb::Util

  def initialize
    require 'pathname'

    @config = Config.new(
      'http://aur.archlinux.org/rpc.php?type=search&arg=%s',
      'http://aur.archlinux.org/rpc.php?type=info&arg=%s',
      '/var/lib/pacman/sync/community',
      Pathname.new(DlPath).realpath
    )
    @opts = Opts.new(ARGV)
  end

  def start
    trap(:INT) { exit 0 } # Exit peacefully on *INT

    # Evaluate a command in string form
    # Example: instance_eval('search("package")')
    # Which will invoke the search method
    instance_eval @opts[:cmd]
  rescue AurbError => e
    $stderr.puts e.message
    exit 1
  end

  # Downloads +packages+
  #
  #   download('awesome-git', 'aurb')
  #
  def download *packages
    packages.each do |package|
      list(package).each do |names|
        if names.first == package
          if in_sync? package
            puts "#{ansi('==>', :yellow)} Found #{package} in community. Use pacman!"
          else
            Dir.chdir(@config.dir) do
              fetch package
              untar package
            end
          end
        end
      end
    end
  end

  # Searches for +package+
  #
  #   search('awesome')
  #
  def search package
    count, threads = 0, []

    list(package).each do |names|
      result = json(@config.info % names[1])

      unless result['type'] == 'error'
        result = result['results']

        next if in_sync? result['Name']

        if package.any? do |pac| # Check both name and description for matches
          (result['Name'].include?(pac)) || (result['Description'].include?(pac))
        end
          count += 1

          puts "[#{result['OutOfDate'] == '1' ? ansi('✘', :red) : ansi('✔', :green)}] \
#{ansi(result['Name'], :blue)} (#{result['Version']}): #{result['Description']}"
        end
      end
    end
  end

  # Checks the aur for upgrades to local packages that were not found in any
  # official repository.
  #
  def check_upgrade
    count, upgradable = 0, []

    puts "#{ansi('==>', :yellow)} Searching for upgrades. This may take a while..."
    `pacman -Qm`.each_line do |line|
      name, version = line.chomp.split
      result = json(@config.info % name)

      unless result['type'] == 'error'
        result = result['results']

        next if in_sync? result['Name']

        if (result.is_a?(Hash)) && (result['Version'] != version)
          require 'facets/version'

          if VersionNumber.new(result['Version']) > VersionNumber.new(version)
            count += 1
            upgradable << name

            puts "#{ansi(name, :bold)} #{ansi(version, :red)} -> \
#{ansi(result['Version'], :green)}"
          end
        end
      end
    end

    if upgradable.empty? && count == 0
      puts "#{ansi('==>', :yellow)} Everything is up to date"
    else
      require 'readline'

      puts "#{ansi('==>', :yellow)} Targets (#{count}): #{upgradable.join(', ')}"

      upgradable.each do |pkg|
        answer = Readline::readline("#{ansi('==>', :yellow)} Download #{pkg}? ")
        answer =~ /^y|yes$/i ? download(pkg) : next
      end
    end
  end

private
  # Checks if a package exists in the community repository
  #
  #   in_sync?('awesome-git')
  #
  def in_sync? package
    !!Dir["#{@config.sync}/#{package}-*"].first
  end

  # Returns a list of packages found by a search
  #
  #   list('awesome-git')
  #
  def list package
    require 'cgi'

    info, list = json(@config.search % CGI::escape(package)), []

    unless info['type'] == 'error'
      info['results'].each do |result|
        list << [result['Name'], result['ID']]
      end
    end

    list.sort
  end

  # Downloads given +package+ into +dir+
  #
  #   fetch('awesome-git', $0.dirname)
  #
  def fetch package
    File.delete("#{package}.tar.gz") if File.exists?("#{package}.tar.gz")

    open("http://aur.archlinux.org/packages/#{package}/#{package}.tar.gz") do |remote|
      File.open("#{package}.tar.gz", 'wb') do |local|
        local.write(remote.read)
      end
    end

    puts "#{ansi('==>', :yellow)} Fetched #{package}.tar.gz"
  end

  # Untars +package+
  #
  #   untar('awesome-git') #=> .tar.gz is automagically appended
  #
  def untar package
    require 'facets/minitar'
    require 'zlib'
    require 'fileutils'

    FileUtils.rm_r(package) if File.directory?(package)

    Archive::Tar::Minitar.unpack(
      Zlib::GzipReader.new(File.open("#{package}.tar.gz", 'rb')), Dir.pwd
    )

    puts "#{ansi('==>', :yellow)} Untarred #{package}.tar.gz"
  end

  # Shortcut to parsing json
  #
  #   json('http://foo.bar')
  #
  def json item
    require 'json'

    JSON.parse(open(item).read)
  end
end

class Opts < Hash
  def initialize(args = ARGV)
    @@args = args.empty? ? ['-h'] : args
    parse
  end

private
  def parse
    require 'optparse'

    OptionParser.new do |o|
      o.version      = [0, 5, 8].join('.')
      o.program_name = 'Aurb'
      o.release      = '2009-04-15'

      o.on('-D', '--download P1,P2,...', Array, "Download package(s).") do |d|
        self[:cmd] = "download('#{d*"', '"}')"
      end

      o.on('-S', '--search PKG', 'Search for a package.') do |s|
        self[:cmd] = "search('#{s}')"
      end

      o.on('-U', '--upgrade', 'Check the AUR for upgrades.') do
        self[:cmd] = 'check_upgrade'
      end
    end.parse! @@args
  end
end

end

at_exit do
  if __FILE__ == $0
    raise $! if $!
    Aurb.aur.start
  else
    $stderr.puts 'Please only run me by myself. Thanks.'
    exit 1
  end
end
