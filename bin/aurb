#!/usr/bin/env ruby
require 'optparse'
require 'fileutils'
require 'rubygems'
require 'cgi'
require 'json'
require 'open-uri'
require 'pathname'
require 'zlib'
require 'facets/ansicode'
require 'facets/minitar'
require 'facets/version'

module Aurb
  Config  = Struct.new(:search, :info, :sync, :dir)
  Version = [0, 5, 5]
  # Change Me!
  DlPath  = File.join(File.expand_path('~'), 'abs') # => '/home/gig/abs'

  def self.aur
    @aur ||= Aur.new
  end

  module Util
    # Colorize a string
    #
    #   color('Text', :green)
    #
    # For a full list of available effects, see
    # http://facets.rubyforge.org/doc/api/more/classes/ANSICode.html
    def color(text, effect)
      ANSICode.send(effect.to_sym) << text << ANSICode.clear
    end
  end

  class AurbError < Exception; end

  class Aur
    include Aurb::Util

    def initialize
      @config = Config.new(
        'http://aur.archlinux.org/rpc.php?type=search&arg=%s',
        'http://aur.archlinux.org/rpc.php?type=info&arg=%s',
        '/var/lib/pacman/sync/community',
        Pathname.new(DlPath).realpath
      )
      @opts = Opts.new(ARGV)
    end

    # Starts Aurb
    def start
      # Exit peacefully on *INT
      trap(:INT) { exit 0 }
      # Evaluate a command in string form
      # Example: instance_eval('search("package")')
      # Which will invoke the search method
      instance_eval(@opts[:cmd])
    rescue AurbError => e
      $stderr.puts e.message
      exit 1
    end

    # Downloads +packages+
    #
    #   download('awesome-git', 'aurb')
    #
    def download(*packages)
      packages.each do |package|
        list(package).each do |names|
          if names.first == package
            # Check if the package exists in the community repo
            # Invoke pacman if so
            if in_sync? package
              puts "#{color('==>', :yellow)} Found #{package} in community repo. \
Pacman will do."
              exec "sudo pacman -S #{package}"
            else
            # Else download and untar it from the AUR
              Dir.chdir(@config.dir) do |dir|
                # Remove old files if they already exist instead of overwriting
                FileUtils.rm("#{package}.tar.gz") if File.exists?("#{package}.tar.gz")
                fetch(package, dir)
                puts "#{color('==>', :yellow)} Downloaded #{package}"
                FileUtils.rm_r(package) if File.directory?(package)
                untar(package)
                puts "#{color('==>', :yellow)} Unpacked #{package}"
              end
            end
          end
        end
      end
    end

    # Searches for +package+
    #
    #   search('awesome')
    #
    def search(package)
      count, threads = 0, []
      list(package).each do |names|
        # Launch a separate thread for each packagename to be checked
        # This is slooow otherwise, because it will have to wait for each result
        # to be displayed before going on to the next one
        threads << Thread.new do
          result = json(@config.info % names[1])
          unless result['type'] == 'error'
            result = result['results']
            # Skip this iteration if the package is found in the community repo
            next if in_sync? result['Name']
            if package.any? do |pac|
              # Check both name and description for matches
              (result['Name'].include?(pac)) || (result['Description'].include?(pac))
            end
              count += 1
              puts "[#{result['OutOfDate'] == '1' ? color('✘', :red) : color('✔', :green)}] \
#{color(result['Name'], :blue)} (#{result['Version']}): #{result['Description']}"
            end
          end
        end
      end
      # Join the threads after searching is finished
      threads.each { |t| t.join }

      puts "\n#{color('==>', :yellow)} Found #{color(count.to_s, :magenta)} \
#{count == 1 ? 'result' : 'results'}"
    end

    # Checks the aur for upgrades to local packages that were not found in any
    # official repository.
    def check_upgrade
      count, upgradable = 0, []
      `pacman -Qm`.each_line do |line|
        # Pacman -Qm output: name 1.1-1
        # Split them up in variables
        name, version = line.chomp.split
        result = json(@config.info % name)
        # Ensure that packages are on the aur before checking
        unless result['type'] == 'error'
          result = result['results']
          # Check if local version != remote version
          if (result.is_a?(Hash)) && (result['Version'] != version)
            # Make sure the remote version is newer
            if VersionNumber.new(result['Version']) > VersionNumber.new(version)
              count += 1
              # Insert the upgradable package's name into an array which we will
              # use later to prompt the download
              upgradable << name
              puts "#{color(name, :bold)} (#{color(version, :red)}) \
can be upgraded to #{color(result['Version'], :green)}"
            end
          else
            puts "#{color(name, :bold)} (#{color(version, :green)}) is up to date"
          end
        end
      end

      puts "\n#{color('==>', :yellow)} Found #{color(count.to_s, :magenta)} \
#{count == 1 ? 'upgrade' : 'upgrades'}"
      unless upgradable.empty?
        # Prompt asking to download the upgrades
        upgradable.each do |pkg|
          print "#{color('==>', :yellow)} Download '#{pkg}'? [y] "
          $stdin.gets.chomp =~ /^y/ ? download(pkg) : next
        end
      end
    end

  private
    # Checks if a package exists in the community repository
    #
    #   in_sync?('awesome-git')
    #
    def in_sync?(package)
      Dir["#{@config.sync}/#{package}-*"].first ? true : false
    end

    # Returns a list of packages found by a search
    #
    #   list('awesome-git')
    #
    def list(package)
      info, list = json(@config.search % CGI::escape(package)), []
      if info['type'] == 'error'
        raise AurbError, "#{color('Fatal', :on_red)}: no results"
      end
      for result in info['results'] do
        list << [result['Name'], result['ID']]
      end
      list.sort unless list.empty?
    end

    # Downloads given +package+ into +dir+
    #
    #   fetch('awesome-git', $0.dirname)
    #
    def fetch(package, dir)
      open("http://aur.archlinux.org/packages/#{package}/#{package}.tar.gz") do |remote|
        File.open("#{dir}/#{package}.tar.gz", 'wb') do |local|
          local.write(remote.read)
        end
      end
    end

    # Untars +package+
    #
    #   untar('awesome-git')   #=> .tar.gz is automagically appended
    #
    def untar(package)
      Archive::Tar::Minitar.unpack(
        Zlib::GzipReader.new(File.open("#{package}.tar.gz", 'rb')),
        Dir.pwd
      )
    end

    # Shortcut to parsing json
    #
    #   json('http://foo.bar')
    #
    def json(item)
      JSON.parse(open(item).read)
    end
  end

  class Opts < Hash
    def initialize(args = ARGV)
      @@args = args.empty? ? ['-h'] : args

      # Invoke this class's only private method
      parse
    end

  private
    def parse
      OptionParser.new do |o|
        o.version      = Version.join('.')
        o.program_name = 'Aurb'
        o.release      = '2009-04-12'

        o.on('-D', '--download P1,P2,...', Array, "Download package(s). \
Separate by commas if multiple (no spaces).") do |d|
          self[:cmd] = "download('#{d*"', '"}')"
        end
        o.on('-S', '--search PKG', 'Search for a package.') do |s|
          self[:cmd] = "search('#{s}')"
        end
        o.on('-U', '--upgrade', 'Check for upgrades.') do
          self[:cmd] = 'check_upgrade'
        end
      end.parse!(@@args)
    end
  end
end

at_exit do
  if __FILE__ == $0
    raise $! if $!
    Aurb.aur.start
  end
end
