#!/usr/bin/env ruby
%w(optparse rubygems cgi json open-uri pathname zlib facets/ansicode facets/minitar facets/version).each do |lib|
  require lib
end

module Aurb
  Config  = Struct.new(:search, :info, :sync, :dir)
  Version = [0, 5, 4]
  # Change Me!
  DlPath  = File.join(File.expand_path('~'), 'abs') # => '/home/gig/abs' in my case

  def self.aur
    @aur ||= Aur.new
  end

  module Util
    # Colorize a string
    # Example: color('Text', :green)
    def color(text, effect)
      ANSICode.send(effect.to_sym) << text << ANSICode.clear
    end
  end

  class AurbError < Exception; end

  class Aur
    include Aurb::Util

    def initialize
      @config = Config.new(
        'http://aur.archlinux.org/rpc.php?type=search&arg=%s',
        'http://aur.archlinux.org/rpc.php?type=info&arg=%s',
        '/var/lib/pacman/sync/community',
        Pathname.new(DlPath).realpath
      )
      @opts = Opts.new(ARGV)
    end

    def start
      # Exit peacefully on *INT
      trap(:INT) { exit 0 }
      # Evaluate a command in string form
      # Example: instance_eval('search("package")')
      # Which will invoke the search method
      instance_eval(@opts[:cmd])
    rescue AurbError => e
      $stderr.puts e.message
      exit 1
    end

    def download(*packages)
      packages.each do |package|
        list(package).each do |names|
          if names.first == package
            # Check if the package exists in the community repo
            # Invoke pacman if so
            if in_sync? package
              puts "#{color('==>', :yellow)} Found #{package} in community repo. Pacman will do."
              exec "sudo pacman -S #{package}"
            else
            # Else download and untar it from the AUR
              Dir.chdir(@config.dir) do |dir|
                fetch(package, dir)
                puts "#{color('==>', :yellow)} Downloaded #{package}"
                untar(package)
                puts "#{color('==>', :yellow)} Unpacked #{package}"
              end
            end
          end
        end
      end
    end

    def search(package)
      count, threads = 0, []
      list(package).each do |names|
        # Launch a separate thread for each packagename to be checked
        # This is slooow otherwise, because it will have to wait for each result
        # to be displayed before going on to the next one
        threads << Thread.new do
          result = json(@config.info % names[1])
          unless result['type'] == 'error'
            result = result['results']
            # Skip this iteration if the package is found in the community repo
            next if in_sync? result['Name']
            # Check both name and description for matches
            if package.any? { |pac| (result['Name'].include?(pac)) || (result['Description'].include?(pac)) }
              count += 1
              puts "[#{result['OutOfDate'] == '1' ? color('✘', :red) : color('✔', :green)}] #{color(result['Name'], :blue)} (#{result['Version']}): #{result['Description']}"
            end
          end
        end
      end
      # Join the threads after searching is finished
      threads.each { |t| t.join }

      puts "\n#{color('==>', :yellow)} Found #{color(count.to_s, :magenta)} #{count == 1 ? 'result' : 'results'}"
    end

    def check_upgrade
      count, upgradable = 0, []
      `pacman -Qm`.each_line do |line|
        # Pacman -Qm output: name 1.1-1
        # Split them up in variables
        name, version = line.chomp.split
        result = json(@config.info % name)
        # Ensure that packages are on the aur before checking
        unless result['type'] == 'error'
          result = result['results']
          # Check if local version != remote version
          if (result.is_a?(Hash)) && (result['Version'] != version)
            # Make sure the remote version is newer
            if VersionNumber.new(result['Version']) > VersionNumber.new(version)
              count += 1
              # Insert the upgradable package's name into an array which we will
              # use later to prompt the download
              upgradable << name
              puts "#{color(name, :bold)} (#{color(version, :red)}) can be upgraded to #{color(result['Version'], :green)}"
            end
          else
            puts "#{color(name, :bold)} (#{color(version, :green)}) is up to date"
          end
        end
      end

      puts "\n#{color('==>', :yellow)} Found #{color(count.to_s, :magenta)} #{count == 1 ? 'upgrade' : 'upgrades'}"
      unless upgradable.empty?
        # Prompt asking to download the upgrades
        upgradable.each do |pkg|
          print "#{color('==>', :yellow)} Download '#{pkg}'? [y] "
          $stdin.gets.chomp =~ /^y/ ? download(pkg) : next
        end
      end
    end

  private
    def in_sync?(package)
      Dir["#{@config.sync}/#{package}-*"].first ? true : false
    end

    def list(package)
      info, list = json(@config.search % CGI::escape(package)), []
      if info['type'] == 'error'
        raise AurbError, "#{color('Fatal', :on_red)}: no results"
      end
      for result in info['results'] do
        list << [result['Name'], result['ID']]
      end
      list.sort unless list.empty?
    end

    def fetch(package, dir)
      open("http://aur.archlinux.org/packages/#{package}/#{package}.tar.gz") do |remote|
        File.open("#{dir}/#{package}.tar.gz", 'wb') do |local|
          local.write(remote.read)
        end
      end
    end

    def untar(package)
      Archive::Tar::Minitar.unpack(Zlib::GzipReader.new(File.open("#{package}.tar.gz", 'rb')), Dir.pwd)
    end

    def json(item)
      JSON.parse(open(item).read)
    end
  end

  class Opts < Hash
    def initialize(args = ARGV)
      @@args = args.empty? ? ['-h'] : args
      parse
    end

  private
    def parse
      OptionParser.new do |o|
        o.version      = Version.join('.')
        o.program_name = 'Aurb'
        o.release      = '2009-04-10'

        o.on('-D', '--download P1,P2,...', Array, 'Download package(s). Separate by commas if multiple (no spaces).') do |d|
          self[:cmd] = "download('#{d*"', '"}')"
        end
        o.on('-S', '--search PKG', 'Search for a package.') do |s|
          self[:cmd] = "search('#{s}')"
        end
        o.on('-U', '--upgrade', 'Check for upgrades.') do
          self[:cmd] = 'check_upgrade'
        end
      end.parse!(@@args)
    end
  end
end

at_exit do
  if __FILE__ == $0
    raise $! if $!
    Aurb.aur.start
  end
end
