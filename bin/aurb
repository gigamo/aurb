#!/usr/bin/env ruby
libraries = %w[rubygems zlib facets/version facets/minitar facets/ansicode json cgi open-uri optparse]
for library in libraries do
  require library
end

module Aurb
  Config = Struct.new(:search, :info, :sync, :dir)
  Version = [0, 4, 1]

  def self.aur
    @aur ||= Aur.new
  end

  module Util
    def color(text, effect)
      return ANSICode.send(effect) << text << ANSICode.clear
    end
  end

  class AurbError < Exception; end

  class Aur
    include Aurb::Util

    def initialize
      @config = Config.new(
        'http://aur.archlinux.org/rpc.php?type=search&arg=%s',
        'http://aur.archlinux.org/rpc.php?type=info&arg=%s',
        '/var/lib/pacman/sync/%s',
        # Change this to reflect your personal download path
        File.join(ENV['HOME'], 'abs')
      )
      @opts = Opts.new(ARGV)
    end

    def start
      if @opts[:cmd]
        instance_eval(@opts[:cmd])
      else
        raise AurbError, "#{color('Fatal', :on_red)}: no option given, see --help"
      end
    rescue AurbError => e
      puts e.message
      exit
    end

    def download(*packages)
      for package in packages do
        unless File.exists? File.join(@config.dir, package)
          for names in list(package) do
            if names.first == package
              Dir.chdir(@config.dir) do |dir|
                if in_sync? package, 'community'
                  puts "#{color('==>', :yellow)} Found #{package} in community repo. Pacman will do."
                  # exec will automatically terminate the script
                  exec "sudo pacman -S #{package}"
                else
                  puts "#{color('==>', :yellow)} Downloading #{package}."
                  open("http://aur.archlinux.org/packages/#{package}/#{package}.tar.gz") do |remote|
                    File.open("#{dir}/#{package}.tar.gz", 'wb') do |file|
                      file.write(remote.read)
                    end
                  end
                end

                puts "#{color('==>', :yellow)} Unpacking #{package}."
                Archive::Tar::Minitar.unpack(
                  Zlib::GzipReader.new(File.open("#{package}.tar.gz", 'rb')),
                  Dir.pwd
                )
              end
            end
          end
        else
          raise AurbError, "#{color('Fatal', :on_red)}: directory already exists"
        end
      end
    end

    def search(package)
      threads, count = [], 0
      for name in list(package) do
        threads << Thread.new do
          result = JSON.parse(open(@config.info % name[1]).read)
          if result['type'] == 'error'
            raise AurbError, "#{color('Fatal', :on_red)}: no results"
          else
            result = result['results']
            next if in_sync? result['Name'], 'community'
            if package.any? do |pac|
                result['Name'].include? pac or result['Description'].include? pac
              end
              count += 1

              puts "[#{result['OutOfDate'] == '1' ? color('✘', :red) : color('✔', :green)}] #{color(result['Name'], :blue)} (#{result['Version']}): #{result['Description']}"
            end
          end
        end
      end
      threads.each { |t| t.join }

      if count == 0
        raise AurbError, "#{color('Fatal', :on_red)}: no results"
      else
        puts "\n#{color('==>', :yellow)} Found #{color(count.to_s, :magenta)} #{count == 1 ? 'result' : 'results'}."
      end
    end

    def check_upgrade
      threads, found, upcount = [], false, 0
      puts "#{color('==>', :yellow)} Checking for upgrades."
      `pacman -Qm`.each_line do |line|
        threads << Thread.new do
          name, version = line.chomp.split
          result = JSON.parse(open(@config.info % name).read)
          if result === Hash && result['Version'] != version
            found = true
            if VersionNumber.new(result['Version']) > VersionNumber.new(version)
              puts "#{color(name, :bold)}: #{color(version, :red)} -> #{color(result['Version'], :green)}"
              upcount += 1
            end
          else
            puts "#{color(name, :bold)} is up to date"
          end
        end
      end
      threads.each { |t| t.join }

      if found
        puts "\n#{color('==>', :yellow)} Found #{color(upcount.to_s, :magenta)} #{upcount == 1 ? 'upgrade' : 'upgrades'}."
      else
        puts "\n#{color('==>', :yellow)} All packages are up to date."
      end
    end

  private
    def in_sync?(package, repo)
      repo = @config.sync % repo
      return true if Dir["#{repo}/#{package}-*"].first
    end

    def list(package)
      info, list = JSON.parse(open(@config.search % CGI::escape(package)).read), []
      if info['type'] == 'error'
        raise AurbError, "#{color('Fatal', :on_red)}: no results"
      end
      for result in info['results'] do
        list << [result['Name'], result['ID']]
      end

      return list.sort
    end
  end

  class Opts < Hash
    def initialize(args)
      parse(args)
    end

  private
    def parse(args)
      OptionParser.new do |o|
        o.version      = Version*'.'
        o.program_name = 'Aurb'
        o.release      = '2009-04-06'

        o.on('-D', '--download P1,P2,...', Array, 'Download package(s). Separate by commas if multiple (no spaces).') do |d|
          self[:cmd] = "download('#{d*'\', \''}')" # wow. ugly
        end
        o.on('-S', '--search PKG', 'Search for a package.') do |s|
          self[:cmd] = "search('#{s}')" % s
        end
        o.on('-U', '--upgrade', 'Check for upgrades.') do
          self[:cmd] = 'check_upgrade'
        end
      end.parse!(args)
    end
  end
end

at_exit do
  if __FILE__ == $0
    raise $! if $!
    Aurb.aur.start
  end
end
