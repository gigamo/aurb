#!/usr/bin/env ruby
#  Author:: Gigamo &lt;gigamo@gmail.com&gt;
# License:: GPL
#
%w[optparse pathname fileutils readline rubygems cgi json zlib
open-uri facets/ansicode facets/minitar facets/version].each do |lib|
  require lib
end

module Aurb

DlPath = File.join File.expand_path('~'), 'abs' # Change me!
Config = Struct.new :search, :info, :dir  # Don't change me!

def self.aur
  @aur ||= Aur.new
end

module Util
  # Colorize a string
  #
  #   ansi('Text', :green)
  #
  # For a full list of available effects, go to:
  # http://facets.rubyforge.org/doc/api/more/classes/ANSICode.html
  #
  def ansi text, effect
    (@opts[:color] ? ANSICode.send(effect.to_sym) : '') << text << ANSICode.clear
  end
  module_function :ansi
end

class Aur
  include Aurb::Util

  def initialize
    @config = Config.new(
      'http://aur.archlinux.org/rpc.php?type=search&arg=%s',
      'http://aur.archlinux.org/rpc.php?type=info&arg=%s',
      Pathname.new(DlPath).realpath
    )
    @opts = Opts.new
  end

  def start
    trap :INT do
      puts "\nInterrupt signal received\n\n"
      exit 0 # Exit peacefully
    end

    # Evaluate a command in string form
    # 
    #   instance_eval('search("package")')
    #
    instance_eval @opts[:cmd]
  end

  # Downloads +packages+
  #
  #   download('awesome-git', 'aurb')
  #
  def download *packages
    packages = packages[0] if packages[0].is_a? Array

    puts "Targets (#{ansi "#{packages.length}", :magenta}): #{packages.join(', ')}"
    answer = Readline::readline "\nProceed? [y/n] "

    if answer =~ /^y|yes$/i
      packages.each do |package|
        list(package).each do |names|
          if names[0] == package
            Dir.chdir(@config.dir) do
              fetch package
              untar package

              puts "(#{ansi "#{packages.index(package) + 1}", :green}/\
#{ansi "#{packages.length}", :yellow}) downloaded #{package}"
            end
          end
        end
      end
    end
  end

  # Searches for +package+
  #
  #   search('awesome')
  #
  def search package
    list(package).each do |names|
      result = json(@config.info % names[1])

      unless result['type'] == 'error'
        result = result['results']

        if package.any? do |pac| # Check both name and description for matches
          (result['Name'].include? pac) || (result['Description'].include? pac)
        end
          puts "[#{result['OutOfDate'] == '1' ? ansi('✘', :red) : ansi('✔', :green)}] \
#{ansi result['Name'], :blue} (#{result['Version']}): #{result['Description']}"
        end
      end
    end
  end

  # Checks the aur for upgrades to local packages that were not found in any
  # official repository.
  #
  def check_upgrade
    return nil if `which pacman`.strip == ''
    upgradable = []

    puts ":: Searching for upgrades. This may take a while..."
    `pacman -Qm`.each_line do |line|
      name, version = line.chomp.split
      result = json(@config.info % name)

      unless result['type'] == 'error'
        result = result['results']

        if result.is_a?(Hash) && VersionNumber.new(result['Version']) > VersionNumber.new(version)
          upgradable << name

          puts " #{name}: #{ansi version, :red} => #{ansi result['Version'], :green}"
        end
      end
    end

    upgradable.empty? ? puts(':: Everything up to date') : download(upgradable)
  end

private
  # Checks if a package exists in the community repository
  #
  #   in_sync?('awesome-git')
  #
  def in_sync? package
    !!Dir["/var/lib/pacman/sync/community/#{package}-*"][0]
  end

  # Returns a list of packages found by a search
  #
  #   list('awesome-git')
  #
  def list package
    info, list = json(@config.search % CGI::escape(package)), []

    unless info['type'] == 'error'
      info['results'].each do |result|
        list << [result['Name'], result['ID']] unless in_sync? result['Name']
      end
    end

    list.sort
  end

  # Downloads given +package+ into +dir+
  #
  #   fetch('awesome-git')
  #
  def fetch package
    File.delete "#{package}.tar.gz" if File.exists? "#{package}.tar.gz"

    open("http://aur.archlinux.org/packages/#{package}/#{package}.tar.gz") do |remote|
      File.open("#{package}.tar.gz", 'wb') do |local|
        local.write(remote.read)
      end
    end
  end

  # Untars +package+
  #
  #   untar('awesome-git') #=> .tar.gz is automagically appended
  #
  def untar package
    FileUtils.rm_r package if File.directory? package

    Archive::Tar::Minitar.unpack(
      Zlib::GzipReader.new(File.open("#{package}.tar.gz", 'rb')), Dir.pwd
    )
  end

  # Shortcut to parsing json
  #
  #   json('http://foo.bar')
  #
  def json item
    JSON.parse(open(item).read)
  end
end

class Opts < Hash
  def initialize
    self[:args]  = ARGV.empty? ? ['-h'] : ARGV
    self[:color] = true

    parse
  end

private
  def parse
    OptionParser.new do |o|
      o.version      = [0, 6, 2].join('.')
      o.program_name = 'Aurb'
      o.release      = '2009-04-19'

      o.separator 'Actions:'

      o.on '-D', '--download P1,P2,...', Array, 'download package(s)' do |d|
        self[:cmd] = "download('#{d*"', '"}')"
      end

      o.on '-S', '--search PKG', 'search for a package' do |s|
        self[:cmd] = "search('#{s}')"
      end

      o.on '-U', '--upgrade', 'check the AUR for upgrades' do
        self[:cmd] = 'check_upgrade'
      end

      o.separator 'Optional:'

      o.on '--[no-]color', "use colors? [#{self[:color]}]" do |c|
        self[:color] = c
      end
    end.parse! self[:args]
  end
end

end

at_exit do
  if __FILE__ == $0
    raise $! if $!
    Aurb.aur.start
  end
end
