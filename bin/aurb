#!/usr/bin/env ruby
#  Author:: Gigamo &lt;gigamo@gmail.com&gt;
# License:: GPL
#
%w[optparse pathname fileutils readline zlib open-uri rubygems cgi json 
   facets/ansicode facets/minitar facets/version].each { |lib| require lib }

module Aurb

# Path where PKGBUILDS will get saved to
  DlPath = File.join File.expand_path('~'), 'abs'

# Program Info
  PrInfo = {:name => 'Aurb', :version => [0, 6, 2].join('.'), :release => '2009-04-19'}

  def self.aur
    @aur ||= Aur.new \
      :search => 'http://aur.archlinux.org/rpc.php?type=search&arg=%s',
      :info   => 'http://aur.archlinux.org/rpc.php?type=info&arg=%s',
      :path   => Pathname.new(DlPath).realpath
  end

  module Util
    def ansi text, effect
      text = ANSICode.send(effect.to_sym) << text << ANSICode.clear if @opts.color
      text
    end
  end

  class Aur
    include Aurb::Util

    def initialize config = {}
      @config = config
      @opts = Opts.new
    end

    def start
      trap :INT do
        puts "\nInterrupt signal received\n\n"
        exit 0
      end

      instance_eval @opts.cmd
    end

    def download *packages
      packages = packages.first if packages.first.is_a? Array

      puts "Targets (#{ansi "#{packages.length}", :magenta}): #{packages.join(', ')}"
      answer = Readline::readline "Proceed? [y/n] "

      if answer =~ /^y|yes$/i
        packages.each do |package|
          list(package).each do |names|
            if names.first == package
              FileUtils.cd @config[:path] do
                fetch package
                untar package
              end
              puts "(#{ansi "#{packages.index(package) + 1}", :green}/" + 
                "#{ansi "#{packages.length}", :green}) downloaded #{package}"
            end
          end
        end
      end
    end

    def search package
      list(package).each do |names|
        result = json(@config[:info] % names.last)

        unless result['type'] == 'error'
          result = result['results']

          if package.any? do |pac| # Check both name and description for matches
            (result['Name'].include? pac) || (result['Description'].include? pac)
          end
            puts "[#{result['OutOfDate'] == '1' ? ansi('✘', :red) : ansi('✔', :green)}] " +
              "#{ansi result['Name'], :blue} (#{result['Version']}): #{result['Description']}"
          end
        end
      end
    end

    def check_upgrade
      raise 'Pacman binary was not found. ' + 
        'Are you running Arch Linux?' if `which pacman`.strip == ''
      upgradable = []

      puts ':: Searching for updates. This may take a while...'
      `pacman -Qm`.each_line do |line|
        name, version = line.chomp.split
        result = json(@config[:info] % name)

        unless result['type'] == 'error'
          result = result['results']

          if VersionNumber.new(result['Version']) > VersionNumber.new(version)
            upgradable << result['Name']
            puts "  #{result['Name']}: #{ansi version, :red} => " +
              "#{ansi result['Version'], :green}"
          end
        end
      end

      upgradable.empty? ? puts(':: Everything up to date') : download(upgradable)
    end

  private
    def in_sync? package
      !!Dir["/var/lib/pacman/sync/community/#{package}-*"].first
    end

    def list package
      info, list = json(@config[:search] % CGI::escape(package)), []

      unless info['type'] == 'error'
        info['results'].each do |result|
          list << [result['Name'], result['ID']] unless in_sync? result['Name']
        end
      end

      list.sort
    end

    def fetch package
      FileUtils.rm "#{package}.tar.gz" if File.exists? "#{package}.tar.gz"

      open("http://aur.archlinux.org/packages/#{package}/#{package}.tar.gz") do |remote|
        File.open("#{package}.tar.gz", 'wb') do |local|
          local.write remote.read
        end
      end
    end

    def untar package
      FileUtils.rm_r package if File.directory? package

      Archive::Tar::Minitar.unpack \
        Zlib::GzipReader.new(File.open("#{package}.tar.gz", 'rb')),
        Dir.pwd
    end

    def json item
      JSON.parse(open(item).read)
    end
  end

  class Opts
    attr_reader :cmd, :color

    def initialize
      @@args = ARGV.empty? ? ['-h'] : ARGV
      @color = true

      parse!
    end

  private
    def parse!
      OptionParser.new do |o|
        o.program_name, o.version, o.release = \
          [:name, :version, :release].map {|key| PrInfo[key]}

        o.separator 'Actions (Required):'

        o.on '-D', '--download P1,P2,...', Array, 'download package(s)' do |d|
          @cmd = "download('#{d*"', '"}')"
        end

        o.on '-S', '--search PKG', 'search for a package' do |s|
          @cmd = "search('#{s}')"
        end

        o.on '-U', '--upgrade', 'check the AUR for upgrades' do
          @cmd = 'check_upgrade'
        end

        o.separator 'Optional:'

        o.on '--[no-]color', "use colors? [#{@color ? 'yes' : 'no'}]" do |c|
          @color = c
        end
      end.parse! @@args
    end
  end
end

at_exit do
  if __FILE__ == $0
    raise $! if $!
    Aurb.aur.start
  end
end
