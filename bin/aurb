#!/usr/bin/env ruby
# aurb
#
# Copyright (C) 2009 Gigamo
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#
# Inspired by arson (http://evaryont.github.com/arson)
require 'rubygems'

{
  :getopt    => ['getoptlong',      true ],
  :pathname  => ['pathname',        false],
  :zlib      => ['zlib',            true ],
  :openuri   => ['open-uri',        true ],
  :json      => ['json',            true ],
  :gettext   => ['gettext',         false],
  :highline  => ['highline/import', false],
  :ansicode  => ['facets/ansicode', false],
  :minitar   => ['facets/minitar',  false],
  :version   => ['facets/version',  false],
}.each do |key, info|
  path, required = info[0, 2]
  $have_lib ||= {}

  begin
    require path
    $have_lib[key] = true
  rescue LoadError
    if required
      abort <<-ERR
You're missing '#{lib}'.
Please make sure you have the necessary rubygems installed.
      ERR
    else
      $have_lib[key] = false
    end
  end
end

def _ str
  $have_lib[:gettext] ? GetText::_(str) : str
end

module Aurb
# Default download path
  DlPath = File.join ENV['HOME'], 'abs'

# Program info
  PrInfo = {:name => 'Aurb', :version => [0, 8, 3].join('.'), :release => '2009-05-07'}

  class << self
    def aur
      @aur ||= Aur.new \
        :rpc => proc {|type, arg| "http://aur.archlinux.org/rpc.php?type=#{type}&arg=#{arg}"}
    end
  end

  module Util
    def ansi text, effect
      if @config[:color] && $have_lib[:ansicode]
        text = ANSICode.send(effect.to_sym) << text.to_s << ANSICode.clear
      end
      text
    end

    def yes_or_no? question
      if $have_lib[:highline]
        ask question, lambda {|yn| yn.downcase[0] == ?y} do |q|
          q.readline              = true
          q.validate              = /\Ay(?:es)?|no?\Z/i
          q.responses[:not_valid] = _('Yes or no, please')
        end
      else
        true
      end
    end
  end

  class Aur
    include Aurb::Util

    def start
      trap :INT do
        $stderr.puts _("\nInterrupt signal received\n\n")
        exit 0
      end

      @opts.cmd.each do |cmd|
        cmd.length == 1 ? __send__(cmd.first) : __send__(cmd.first, cmd.last)
        $stdout.puts "\n\n-----" unless cmd == @opts.cmd.last
      end
    end

    def initialize config
      @opts   = Opts.new
      @config = config.merge(@opts.config)
    end

    def download packages
      packages.delete_if {|pkg| in_sync?(pkg)}
      abort _('ERROR: No package(s) to download. Possibly the package(s) you ' +
        'specified was/were found in the community repository?') if packages.empty?

      say _("Targets (#{ansi packages.length, :magenta}): #{packages.join(', ')}")
      if yes_or_no? _('Proceed? [yn] ')
        packages.each do |package|
          begin
            Dir.chdir @config[:path] do
              fetch package
              untar package
            end
          rescue OpenURI::HTTPError
            warn _("WARN: Something went wrong downloading '#{package}'. Are you sure it exists?")
            package == packages.last ? exit : next
          end
          $stdout.puts _("(#{packages.index(package)+1}/#{packages.length}) downloaded #{package}")
        end
      end
    end

    def search packages
      packages.each do |package|
        list(package).each do |id|
          result = json @config[:rpc]['info', id]
          unless result['type'] =~ /error/
            result = result['results']
            next if in_sync? result['Name']
            if package.any? {|pac| result['Name'].include?(pac) || result['Description'].include?(pac)}
              $stdout.puts _("[#{result['OutOfDate'] == '1' ? ansi('✘', :red) : ansi('✔', :green)}] " +
                "#{ansi result['Name'], :blue} (#{result['Version']})\n    #{result['Description']}")
            end
          end
        end
      end
    end

    def check_upgrade
      if $have_lib[:version]
        upgradable ||= []
        IO.popen('pacman -Qm', IO::RDONLY) {|pm| pm.read.lines}.each do |line|
          name, version = line.chomp.split
          result = json @config[:rpc]['info', name]
          unless result['type'] =~ /error/
            result = result['results']
            next if in_sync? result['Name']
            if VersionNumber.new(result['Version']) > VersionNumber.new(version)
              upgradable << result['Name']
              $stdout.puts _("> #{name}: #{ansi version, :red} => #{ansi result['Version'], :green}")
            end
          end
        end
        upgradable.any? ? ($stdout.puts; download upgradable) : ($stdout.puts _('Nothing to update'))
      else
        warn _('WARN: You need the facets rubygem installed to check for updates')
      end
    end

  private
    def in_sync? package
      !!Dir["/var/lib/pacman/sync/community/#{package}-*"].first
    end

    def list package
      list, info = [], json(@config[:rpc]['search', URI.escape(package)])
      unless info['type'] =~ /error/
        info['results'].each do |result|
          list << result['ID']
        end
      end
      list.sort
    end

    def fetch package
      open "http://aur.archlinux.org/packages/#{package}/#{package}.tar.gz" do |remote|
        File.open "#{package}.tar.gz", 'wb' do |local|
          local.write remote.read
        end
      end
    end

    def untar package
      if $have_lib[:minitar]
        Archive::Tar::Minitar.unpack \
          Zlib::GzipReader.new(File.open("#{package}.tar.gz", 'rb')),
          Dir.pwd

        File.delete "#{package}.tar.gz"
      else
        warn _('WARN: You need the facets rubygem installed to untar the package')
      end
    end

    def json item
      JSON.parse open(item).read
    end
  end

  class Opts
    attr_reader :config, :cmd

    def initialize
      @config, @cmd = {:path => DlPath, :color => true}, []

      parse!
      self
    end

  private
    def parse!
      ARGV.unshift '-h' if ARGV.empty?
      gopts = GetoptLong.new \
        ['--download', '-d', GetoptLong::REQUIRED_ARGUMENT],
        ['--search',   '-s', GetoptLong::REQUIRED_ARGUMENT],
        ['--upgrade',  '-u', GetoptLong::NO_ARGUMENT      ],
        ['--no-color',       GetoptLong::NO_ARGUMENT      ],
        ['--path',           GetoptLong::OPTIONAL_ARGUMENT],
        ['--version',  '-v', GetoptLong::NO_ARGUMENT      ],
        ['--help',     '-h', GetoptLong::NO_ARGUMENT      ]

      gopts.each do |opt, arg|
        case opt
        when '--download' then @cmd << ['download', arg.split]
        when '--search'   then @cmd << ['search',   arg.split]
        when '--upgrade'  then @cmd << ['check_upgrade'      ]
        when '--no-color' then @config[:color] = false
        when '--path'     then
          if File.exists? arg = (arg[0...1] == '/' ? arg : File.join(Dir.pwd, arg))
            @config[:path] = Pathname.new(arg).realpath || File.expand_path(arg)
          else
            warn _("WARN: '#{arg}' does not exist. Fell back to [#{@config[:path]}]\n")
          end
        when '--version' then $stdout.puts _('%s %s (%s)' %
          [
            :name, :version, :release
          ].map {|key| PrInfo[key]})
          exit -1
        when '--help'    then print_help
        end
      end
    rescue GetoptLong::Error; exit 2
    end

    def print_help out = $stdout
      out.puts _(<<-HELP)
Aurb - An AUR utility written in Ruby.

Usage:
  #{name = File.basename $0} [options]

Options (Required):
  -d, --download PACKAGE      Download a package.
  -s, --search PACKAGE        Search for package(s).
  -u, --upgrade               Search for package updates.

Optional:
      --no-color              Disable colored output.
      --path [PATH]           Override the default save path. [#{@config[:path]}]

Other:
      --version               Show version and exit.
      --help                  This message.

Examples:
  #{name} -d 'package1 package2' --path ~/downloads
  #{name} -s 'package1 package2' --no-color
  #{name} --upgrade

You can also chain commands, like so:

  #{name} -d 'thispackage' -s 'thatpackage' -u

Aurb was inspired by arson. Do have a look at http://evaryont.github.com/arson
For further information you can contact the author at <gigamo@gmail.com>.
      HELP
      exit -1
    end
  end
end

at_exit do
  if __FILE__ == $0
    raise $! if $!
    Aurb.aur.start
  end
end

__END__

=head1 NAME

Aurb - An AUR utility written in Ruby

=head1 SYNOPSIS

  aurb --help

=head1 DESCRIPTION

Aurb is a small AUR utility written in Ruby. It can download and search for packages,
and search the AUR for updates to local packages. Run aurb -h for more information.

=head1 AUTHOR

Gigamo <lt>gigamo at gmail dot com<gt>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2009 Gigamo

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

=cut
