#!/usr/bin/env ruby
libraries = %w[rubygems zlib facets/version facets/minitar facets/ansicode json cgi open-uri optparse]
for library in libraries do
  require library
end

module Aurb
  Config = Struct.new(:search, :info, :sync, :dir)
  Version = [0, 3, 1]

  def self.aur
    @aur ||= Aur.new
  end

  module Util
    def color(text, effect)
      return ANSICode.send(effect) << text << ANSICode.clear
    end
  end

  class AurbError < Exception; end

  class Aur
    include Aurb::Util
    attr_accessor :config

    def initialize
      @config = Config.new(
        'http://aur.archlinux.org/rpc.php?type=search&arg=%s',
        'http://aur.archlinux.org/rpc.php?type=info&arg=%s',
        '/var/lib/pacman/sync/%s',
        # Change this to reflect your personal download path
        File.join(ENV['HOME'], 'abs')
      )
      @opts = Opts.new(ARGV)
    end

    def start
      begin
        if @opts[:cmd]
          instance_eval(@opts[:cmd])
        else
          raise AurbError, "#{color('Fatal', :on_red)}: no option given, see --help"
        end
      rescue AurbError => e
        puts e.message
      end
    end

    def download(package)
      unless File.exists? File.join(@config.dir, package)
        for names in list(package) do
          if names.first == package
            Dir.chdir(@config.dir) do |dir|
              if in_sync? package, 'community'
                puts "#{color('==>', :yellow)} Found #{package} in community repo. Pacman will do."
                # exec will automatically terminate the script
                exec "sudo pacman -S #{package}"
              else
                puts "#{color('==>', :yellow)} Downloading #{package}."
                open("http://aur.archlinux.org/packages/#{package}/#{package}.tar.gz") do |remote|
                  File.open("#{dir}/#{package}.tar.gz", 'wb') do |file|
                    file.write(remote.read)
                  end
                end
              end

              puts "#{color('==>', :yellow)} Unpacking #{package}."
              Archive::Tar::Minitar.unpack(
                Zlib::GzipReader.new(File.open("#{package}.tar.gz", 'rb')),
                Dir.pwd
              )
            end
          end
        end
      else
        raise AurbError, "#{color('Fatal', :on_red)}: directory already exists"
      end
    end

    def search(package)
      threads, count = [], 0
      for name in list(package) do
        threads << Thread.new do
          result = JSON.parse(open(@config.info % name[1]).read)
          if result['type'] == 'error'
            raise AurbError, "#{color('Fatal', :on_red)}: no results"
          else
            result = result['results']
            next if in_sync? result['Name'], 'community'
            if package.any? do |pac|
                result['Name'].include? pac or result['Description'].include? pac
              end
              count += 1

              puts "[#{result['OutOfDate'] == '1' ? color('✘', :red) : color('✔', :green)}] #{color(result['Name'], :blue)} (#{result['Version']}): #{result['Description']}"
            end
          end
        end
      end
      threads.each { |t| t.join }

      puts "\n#{color('==>', :yellow)} Found #{color(count.to_s, :magenta)} #{count == 1 ? 'result' : 'results'}."
    end

    def check_upgrade
      threads, found, upcount = [], false, 0
      puts "#{color('==>', :yellow)} Checking for upgrades."

      `pacman -Qm`.each_line do |line|
        threads << Thread.new do
          name, version = line.chomp.split
          result = JSON.parse(open(@config.info % name).read)
          if result === Hash && result['Version'] != version
            found = true
            if VersionNumber.new(result['Version']) > VersionNumber.new(version)
              puts "#{color(name, :blue)}: #{color(version, :red)} -> #{color(result['Version'], :green)}"
              upcount += 1
            end
          else
            puts "#{color(name, :blue)} is up to date"
          end
        end
      end
      threads.each { |t| t.join }

      if found
        puts "#{color('==>', :yellow)} Found #{upcount.to_s} #{upcount == 1 ? 'upgrade' : 'upgrades'}."
      else
        puts "#{color('==>', :yellow)} All packages are up-to-date."
      end
    end

  private
    def in_sync?(package, repo)
      repo = @config.sync % repo
      return true if Dir["#{repo}/#{package}-*"].first
    end

    def list(package)
      info, list = JSON.parse(open(@config.search % CGI::escape(package)).read), []
      if info['type'] == 'error'
        raise AurbError, "#{color('Fatal', :on_red)}: #{info['results']}"
      end
      for result in info['results'] do
        list << [result['Name'], result['ID']]
      end

      return list.sort
    end
  end

  class Opts < Hash
    def initialize(args)
      parse(args)
    end

  private
    def parse(args)
      OptionParser.new do |o|
        o.version      = Version*'.'
        o.program_name = 'Aurb'
        o.release      = '2009-04-05'

        o.on('-D', '--download=PKG', 'Download +PKG+') do |p| 
          self[:cmd] = "download('#{p}')"
        end
        o.on('-S', '--search=PKG', 'Search for +PKG+') do |p|
          self[:cmd] = "search('#{p}')"
        end
        o.on('-U', '--upgrade', 'Check for upgrades') do
          self[:cmd] = 'check_upgrade'
        end
      end.parse!(args)
    end
  end
end

at_exit do
  if __FILE__ == $0
    raise $! if $!
    Aurb.aur.start
  end
end
