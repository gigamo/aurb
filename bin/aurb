#!/usr/bin/env ruby
require 'rubygems'
require 'zlib'
require 'facets/minitar'
require 'facets/version'
require 'facets/ansicode'
require 'json'
require 'cgi'
require 'open-uri'
require 'optparse'
require 'pathname'

module Aurb
  Config = Struct.new(:search, :info, :sync, :dir)
  Version = {:major => 0, :minor => 4, :tiny => 1}

  def self.aur
    @aur ||= Aur.new
  end

  module Util
    def color(text, effect)
      ANSICode.send(effect) << text << ANSICode.clear
    end
  end

  class AurbError < Exception; end

  class Aur
    include Aurb::Util

    def initialize
      @config = Config.new(
        'http://aur.archlinux.org/rpc.php?type=search&arg=%s',
        'http://aur.archlinux.org/rpc.php?type=info&arg=%s',
        '/var/lib/pacman/sync/%s',
        # Change this to reflect your personal download path
        Pathname.new(File.join(ENV['HOME'], 'abs')).realpath
      )
      @opts = Opts.new(ARGV)
    end

    def start
      trap(:INT) {raise AurbError, 'Catched SIGINT'}

      if @opts[:cmd]
        instance_eval(@opts[:cmd])
      else
        raise AurbError, "#{color('Fatal', :on_red)}: no option given, see --help"
      end
    rescue AurbError => e
      puts e.message
      exit
    end

    def download(*packages)
      packages.each do |package|
        unless File.exists? File.join(@config.dir, package)
          list(package).each do |names|
            if names.first == package
              Dir.chdir(@config.dir) do |dir|
                if in_sync? package, 'community'
                  puts "#{color('==>', :yellow)} Found #{package} in community repo. Pacman will do."
                  # exec will automatically terminate the script
                  exec "sudo pacman -S #{package}"
                else
                  puts "#{color('==>', :yellow)} Downloading #{package}."
                  open("http://aur.archlinux.org/packages/#{package}/#{package}.tar.gz") do |remote|
                    File.open("#{dir}/#{package}.tar.gz", 'wb') do |file|
                      file.write(remote.read)
                    end
                  end
                end

                puts "#{color('==>', :yellow)} Unpacking #{package}."
                Archive::Tar::Minitar.unpack(Zlib::GzipReader.new(File.open("#{package}.tar.gz", 'rb')), Dir.pwd)
              end
            end
          end
        else
          puts "#{color('Warning', :on_yellow)}: directory for #{name} already exists"
          next
        end
      end
    end

    def search(package)
      threads, count = [], 0
      list(package).each do |names|
        threads << Thread.new do
          result = JSON.parse(open(@config.info % names[1]).read)
          if result['type'] == 'error'
            raise AurbError, "#{color('Fatal', :on_red)}: no results"
          else
            result = result['results']
            next if in_sync? result['Name'], 'community'
            if package.any? do |pac|
                (result['Name'].include?(pac)) || (result['Description'].include?(pac))
              end
              count += 1
              puts "[#{result['OutOfDate'] == '1' ? color('✘', :red) : color('✔', :green)}] #{color(result['Name'], :blue)} (#{result['Version']}): #{result['Description']}"
            end
          end
        end
      end
      threads.each { |t| t.join }

      if count > 0
        puts "\n#{color('==>', :yellow)} Found #{color(count.to_s, :magenta)} #{count == 1 ? 'result' : 'results'}."
      end
    end

    def check_upgrade
      threads, uppkgs, found, upcount = [], [], false, 0
      puts "#{color('==>', :yellow)} Checking for upgrades."
      `pacman -Qm`.each_line do |line|
        threads << Thread.new do
          name, version = line.chomp.split
          result = JSON.parse(open(@config.info % name).read)
          if (result === Hash) && (result['Version'] != version)
            if VersionNumber.new(result['Version']) > VersionNumber.new(version)
              puts "#{color(name, :bold)}: #{color(version, :red)} -> #{color(result['Version'], :green)}"
              found = true
              upcount += 1
              uppkgs << name
            end
          else
            puts "#{color(name, :bold)} is up to date"
          end
        end
      end
      threads.each { |t| t.join }

      if found
        puts "\n#{color('==>', :yellow)} Found #{color(upcount.to_s, :magenta)} #{upcount == 1 ? 'upgrade' : 'upgrades'}."
        prompt "Download these packages?" {download(uppkgs*"', '")}
      else
        puts "\n#{color('==>', :yellow)} All packages are up to date."
      end
    end

  private
    def in_sync?(package, repo)
      repo = @config.sync % repo
      true if Dir["#{repo}/#{package}-*"].first
    end

    def prompt(question, &block)
      print "#{question.strip.capitalize} [y/n] "
      answer = $stdin.gets.chomp
      block.call if block_given? && answer ~= /^y/i
    end

    def list(package)
      info, list = JSON.parse(open(@config.search % CGI::escape(package)).read), []
      if info['type'] == 'error'
        raise AurbError, "#{color('Fatal', :on_red)}: no results"
      end
      for result in info['results'] do
        list << [result['Name'], result['ID']]
      end

      list.sort unless list.empty?
    end
  end

  class Opts < Hash
    def initialize(args)
      parse(args)
    end

  private
    def parse(args)
      OptionParser.new do |o|
        o.version      = '%s.%s.%s' % [:major, :minor, :tiny].map {|v| Version[v]}
        o.program_name = 'Aurb'
        o.release      = '2009-04-06'

        o.on('-D', '--download P1,P2,...', Array, 'Download package(s). Separate by commas if multiple (no spaces).') do |d|
          self[:cmd] = "download('#{d*"', '"}')" # wow. ugly
        end
        o.on('-S', '--search PKG', 'Search for a package.') do |s|
          self[:cmd] = "search('#{s}')"
        end
        o.on('-U', '--upgrade', 'Check for upgrades.') do
          self[:cmd] = 'check_upgrade'
        end
      end.parse!(args)
    end
  end
end

at_exit do
  if __FILE__ == $0
    raise $! if $!
    Aurb.aur.start
  end
end
